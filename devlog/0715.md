# 💡 DEVLOG 7/15

- real-time stuff

### #7.7 Subscription Setup part 1

- subscription : long-lasting GraphQL read operation
- PubSubEngine(publish-subscribe) 필요 (아폴로 서버에 내장 - 교육용, 실제서비스 - Redis PubSub 서버 사용)

1. engine의 pubsub instance 만들기

```js
// pubsub.js

import { PubSub } from "apollo-server=express";

const pubsub = new PubSub();

export default pubsub;

// server.js
import pubsub from "./pubsub";
```

2. 변경된 사항에 대해 listen( subscribe)
   - 대화방의 새로운 메세지를 listen (**NEW_MESSAGE라는 이벤트를 subscribe--listening**)

```js
// roomUpdates.typeDefs
type Subscription {
    roomUpdate : Message
}

// roomUpdates.resolvers
Subscription : {
        roomUpdates : {
            subscribe : () => pubsub.asyncIterator(NEW_MESSAGE)
        }
    }

// constants.js
export const NEW_MESSAGE = "NEW_MESSAGE"
```

3. playground에서 subscribe

```
subscription {
  roomUpdates {
    payload
  }
}
```

- 💦 error : `"Could not connect to websocket endpoint ws://localhost:4000/graphql` 

  -> http는 stateless (request-> response -> end) 하기때문

  -> **웹소켓(ws)**는 connection을 열고 실시간으로 주고받음

- 우리가 사용하는 서버는 ws를 다룰 줄 모르기때문에 subscription에 대한 지식을 서버에 설치해야함

```js
// server.js 에 추가
apollo.installSubscriptionHandlers(app);
```



### #7.8 Subscription Setup part 2

- Setup
  - http 서버 상에서 listen
  - our server is handling two different protocols(http, ws)

```js
// server.js

import http from "http"; // 추가

apollo.installSubscriptionHandlers(app); // 삭제

const httpServer = http.createServer(app); // 추가
apollo.installSubscriptionHandlers(httpServer)

httpServer.listen(PORT, () => { ... // 수정
```

- 💦error :  `"Cannot read property 'headers' of undefined"`
  - 웹소켓은 request, response가 없음 (대신 connection이란게 있음)

```js
context: async ({ req }) => {
        return {
            loggedInUser:
                              // 이부분
                await getUser(req.headers.token),
        };
    }
```

- if (req) { ~} 로 수정하고 playground에서 실행



**How/Where to publish the event(NEW_MESSAGE)**

- after creating a message, publish the event
- `pubsub.publish(triggerName,payload)`
  - payload needs to be an object (name_of_subscription : return type of subscription)

```js
// sendMessage.resolvers
const message = await client.message.create({...})
pubsub.publish(NEW_MESSAGE, { roomUpdates: { ...message } });
// "message" object가 아니라 그 안의 내용이 필요

return {...}

```

- 간단정리

1. **subscribe** : asyncIterator를 이벤트의 이름과 함께  return (roomUpdates.resolvers)
2. **publish** : 이벤트의 이름과 payload를 publish (sendMessage.resolvers)



**when should i use subscription?**

- small, incremental changes to large objects (ex. 좋아요 개수를 실시간으로 업데이트)
- low-latency, real-time updates (ex. chatting)



### #7.9 Filtering subscription part 1

- 아직 안전하지 x (필터링 없이 모든 room의 변화를 listening)

**필터1** : listen하고 싶은 roomId를 argument로 받기

```js
// roomUpdates.typeDefs
type Subscription {
        roomUpdates (id:Int!): Message
    }
```

- **withFilter()** 사용

  - `withFilter(function that returns async iterator, filter function(payload, variables))` 

    if filter function returns true : user will get updates

```js
// roomUpdates.resolvers.js
Subscription: {
        roomUpdates: {
            subscribe: withFilter(
                () => pubsub.asyncIterator(NEW_MESSAGE), // function that returns asyncIterator
                ({roomUpdates}, {id}) => {  // filter function (variables에 argument로 보낸 id가 포함)
                    return roomUpdates.roomId === id;                }
                // 보낸 메세지의 roomId가 update 받고자하는 room id(argument로 넣어준)와 같을 때 return true
                // then update 실행
            )
        }
    }
```

- 결과 : roomUpdates(id:5) 를 실행하면 sendMessage(roomId:1) 해도 업데이트되지 않음 (5번방에 대해서만 업데이트하기 때문)

**필터2** : 존재하지 않는 room에 대해서는 listening  하지 않기

**필터3** : subscription resolver를 authentication으로 보호 (protectedResolver는 잘 작동하지 않을 것임 ) - update 받고자 하는 user가 대화방의 참여자가 맞는지 확인



### #7.10 Filtering Subscription part 2

**필터2** : 존재하지 않는 room에 대해서는 listening  하지 않기

- subscription field should return "calling function"(?), not returning function
- withFilter becomes resolver
- same with protectedResolver(function returning other function)

```js
// roomUpdates.resolvers

roomUpdates: {
            subscribe: async (root, args, context, info) => {
                const room = await client.room.findUnique({
                    where: {
                        id: args.id,
                    },
                    select: {
                        id: true
                    }
                })
                if (!room) {
                    throw new Error("you shall not see this.");
                }
                return withFilter(
                    () => pubsub.asyncIterator(NEW_MESSAGE),
                    ({ roomUpdates }, { id }) => {
                        return roomUpdates.roomId === id
                    }
                )(root, args, context, info)
                // subscription field shouldn't return "function"
            }
        }
```



### #7.11 Authentication Subscription

