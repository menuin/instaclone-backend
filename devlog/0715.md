# ðŸ’¡ DEVLOG 7/15

- real-time stuff

### #7.7 Subscription Setup part 1

- subscription : long-lasting GraphQL read operation
- PubSubEngine(publish-subscribe) í•„ìš” (ì•„í´ë¡œ ì„œë²„ì— ë‚´ìž¥ - êµìœ¡ìš©, ì‹¤ì œì„œë¹„ìŠ¤ - Redis PubSub ì„œë²„ ì‚¬ìš©)

1. engineì˜ pubsub instance ë§Œë“¤ê¸°

```js
// pubsub.js

import { PubSub } from "apollo-server=express";

const pubsub = new PubSub();

export default pubsub;

// server.js
import pubsub from "./pubsub";
```

2. ë³€ê²½ëœ ì‚¬í•­ì— ëŒ€í•´ listen( subscribe)
   - ëŒ€í™”ë°©ì˜ ìƒˆë¡œìš´ ë©”ì„¸ì§€ë¥¼ listen (**NEW_MESSAGEë¼ëŠ” ì´ë²¤íŠ¸ë¥¼ subscribe--listening**)

```js
// roomUpdates.typeDefs
type Subscription {
    roomUpdate : Message
}

// roomUpdates.resolvers
Subscription : {
        roomUpdates : {
            subscribe : () => pubsub.asyncIterator(NEW_MESSAGE)
        }
    }

// constants.js
export const NEW_MESSAGE = "NEW_MESSAGE"
```

3. playgroundì—ì„œ subscribe

```
subscription {
  roomUpdates {
    payload
  }
}
```

- ðŸ’¦ error : `"Could not connect to websocket endpoint ws://localhost:4000/graphql` 

  -> httpëŠ” stateless (request-> response -> end) í•˜ê¸°ë•Œë¬¸

  -> **ì›¹ì†Œì¼“(ws)**ëŠ” connectionì„ ì—´ê³  ì‹¤ì‹œê°„ìœ¼ë¡œ ì£¼ê³ ë°›ìŒ

- ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ëŠ” ì„œë²„ëŠ” wsë¥¼ ë‹¤ë£° ì¤„ ëª¨ë¥´ê¸°ë•Œë¬¸ì— subscriptionì— ëŒ€í•œ ì§€ì‹ì„ ì„œë²„ì— ì„¤ì¹˜í•´ì•¼í•¨

```js
// server.js ì— ì¶”ê°€
apollo.installSubscriptionHandlers(app);
```



### #7.8 Subscription Setup part 2

- Setup
  - http ì„œë²„ ìƒì—ì„œ listen
  - our server is handling two different protocols(http, ws)

```js
// server.js

import http from "http"; // ì¶”ê°€

apollo.installSubscriptionHandlers(app); // ì‚­ì œ

const httpServer = http.createServer(app); // ì¶”ê°€
apollo.installSubscriptionHandlers(httpServer)

httpServer.listen(PORT, () => { ... // ìˆ˜ì •
```

- ðŸ’¦error :  `"Cannot read property 'headers' of undefined"`
  - ì›¹ì†Œì¼“ì€ request, responseê°€ ì—†ìŒ (ëŒ€ì‹  connectionì´ëž€ê²Œ ìžˆìŒ)

```js
context: async ({ req }) => {
        return {
            loggedInUser:
                              // ì´ë¶€ë¶„
                await getUser(req.headers.token),
        };
    }
```

- if (req) { ~} ë¡œ ìˆ˜ì •í•˜ê³  playgroundì—ì„œ ì‹¤í–‰



**How/Where to publish the event(NEW_MESSAGE)**

- after creating a message, publish the event
- `pubsub.publish(triggerName,payload)`
  - payload needs to be an object (name_of_subscription : return type of subscription)

```js
// sendMessage.resolvers
const message = await client.message.create({...})
pubsub.publish(NEW_MESSAGE, { roomUpdates: { ...message } });
// "message" objectê°€ ì•„ë‹ˆë¼ ê·¸ ì•ˆì˜ ë‚´ìš©ì´ í•„ìš”

return {...}

```

- ê°„ë‹¨ì •ë¦¬

1. **subscribe** : asyncIteratorë¥¼ ì´ë²¤íŠ¸ì˜ ì´ë¦„ê³¼ í•¨ê»˜  return (roomUpdates.resolvers)
2. **publish** : ì´ë²¤íŠ¸ì˜ ì´ë¦„ê³¼ payloadë¥¼ publish (sendMessage.resolvers)



**when should i use subscription?**

- small, incremental changes to large objects (ex. ì¢‹ì•„ìš” ê°œìˆ˜ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸)
- low-latency, real-time updates (ex. chatting)



### #7.9 Filtering subscription part 1

- ì•„ì§ ì•ˆì „í•˜ì§€ x (í•„í„°ë§ ì—†ì´ ëª¨ë“  roomì˜ ë³€í™”ë¥¼ listening)

**í•„í„°1** : listení•˜ê³  ì‹¶ì€ roomIdë¥¼ argumentë¡œ ë°›ê¸°

```js
// roomUpdates.typeDefs
type Subscription {
        roomUpdates (id:Int!): Message
    }
```

- **withFilter()** ì‚¬ìš©

  - `withFilter(function that returns async iterator, filter function(payload, variables))` 

    if filter function returns true : user will get updates

```js
// roomUpdates.resolvers.js
Subscription: {
        roomUpdates: {
            subscribe: withFilter(
                () => pubsub.asyncIterator(NEW_MESSAGE), // function that returns asyncIterator
                ({roomUpdates}, {id}) => {  // filter function (variablesì— argumentë¡œ ë³´ë‚¸ idê°€ í¬í•¨)
                    return roomUpdates.roomId === id;                }
                // ë³´ë‚¸ ë©”ì„¸ì§€ì˜ roomIdê°€ update ë°›ê³ ìží•˜ëŠ” room id(argumentë¡œ ë„£ì–´ì¤€)ì™€ ê°™ì„ ë•Œ return true
                // then update ì‹¤í–‰
            )
        }
    }
```

- ê²°ê³¼ : roomUpdates(id:5) ë¥¼ ì‹¤í–‰í•˜ë©´ sendMessage(roomId:1) í•´ë„ ì—…ë°ì´íŠ¸ë˜ì§€ ì•ŠìŒ (5ë²ˆë°©ì— ëŒ€í•´ì„œë§Œ ì—…ë°ì´íŠ¸í•˜ê¸° ë•Œë¬¸)

**í•„í„°2** : ì¡´ìž¬í•˜ì§€ ì•ŠëŠ” roomì— ëŒ€í•´ì„œëŠ” listening  í•˜ì§€ ì•Šê¸°

**í•„í„°3** : subscription resolverë¥¼ authenticationìœ¼ë¡œ ë³´í˜¸ (protectedResolverëŠ” ìž˜ ìž‘ë™í•˜ì§€ ì•Šì„ ê²ƒìž„ ) - update ë°›ê³ ìž í•˜ëŠ” userê°€ ëŒ€í™”ë°©ì˜ ì°¸ì—¬ìžê°€ ë§žëŠ”ì§€ í™•ì¸



### #7.10 Filtering Subscription part 2

**í•„í„°2** : ì¡´ìž¬í•˜ì§€ ì•ŠëŠ” roomì— ëŒ€í•´ì„œëŠ” listening  í•˜ì§€ ì•Šê¸°

- subscription field should return "calling function"(?), not returning function
- withFilter becomes resolver
- same with protectedResolver(function returning other function)

```js
// roomUpdates.resolvers

roomUpdates: {
            subscribe: async (root, args, context, info) => {
                const room = await client.room.findUnique({
                    where: {
                        id: args.id,
                    },
                    select: {
                        id: true
                    }
                })
                if (!room) {
                    throw new Error("you shall not see this.");
                }
                return withFilter(
                    () => pubsub.asyncIterator(NEW_MESSAGE),
                    ({ roomUpdates }, { id }) => {
                        return roomUpdates.roomId === id
                    }
                )(root, args, context, info)
                // subscription field shouldn't return "function"
            }
        }
```



### #7.11 Authentication Subscription

