# ğŸ’¡ DEVLOG 7/15

- real-time stuff

### #7.7 Subscription Setup part 1

- subscription : long-lasting GraphQL read operation
- PubSubEngine(publish-subscribe) í•„ìš” (ì•„í´ë¡œ ì„œë²„ì— ë‚´ì¥ - êµìœ¡ìš©, ì‹¤ì œì„œë¹„ìŠ¤ - Redis PubSub ì„œë²„ ì‚¬ìš©)

1. engineì˜ pubsub instance ë§Œë“¤ê¸°

```js
// pubsub.js

import { PubSub } from "apollo-server=express";

const pubsub = new PubSub();

export default pubsub;

// server.js
import pubsub from "./pubsub";
```

2. ë³€ê²½ëœ ì‚¬í•­ì— ëŒ€í•´ listen( subscribe)
   - ëŒ€í™”ë°©ì˜ ìƒˆë¡œìš´ ë©”ì„¸ì§€ë¥¼ listen (**NEW_MESSAGEë¼ëŠ” ì´ë²¤íŠ¸ë¥¼ subscribe--listening**)

```js
// roomUpdates.typeDefs
type Subscription {
    roomUpdate : Message
}

// roomUpdates.resolvers
Subscription : {
        roomUpdates : {
            subscribe : () => pubsub.asyncIterator(NEW_MESSAGE)
        }
    }

// constants.js
export const NEW_MESSAGE = "NEW_MESSAGE"
```

3. playgroundì—ì„œ subscribe

```
subscription {
  roomUpdates {
    payload
  }
}
```

- ğŸ’¦ error : `"Could not connect to websocket endpoint ws://localhost:4000/graphql` 

  -> httpëŠ” stateless (request-> response -> end) í•˜ê¸°ë•Œë¬¸

  -> **ì›¹ì†Œì¼“(ws)**ëŠ” connectionì„ ì—´ê³  ì‹¤ì‹œê°„ìœ¼ë¡œ ì£¼ê³ ë°›ìŒ

- ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ëŠ” ì„œë²„ëŠ” wsë¥¼ ë‹¤ë£° ì¤„ ëª¨ë¥´ê¸°ë•Œë¬¸ì— subscriptionì— ëŒ€í•œ ì§€ì‹ì„ ì„œë²„ì— ì„¤ì¹˜í•´ì•¼í•¨

```js
// server.js ì— ì¶”ê°€
apollo.installSubscriptionHandlers(app);
```



### #7.8 Subscription Setup part 2

- Setup
  - http ì„œë²„ ìƒì—ì„œ listen
  - our server is handling two different protocols(http, ws)

```js
// server.js

import http from "http"; // ì¶”ê°€

apollo.installSubscriptionHandlers(app); // ì‚­ì œ

const httpServer = http.createServer(app); // ì¶”ê°€
apollo.installSubscriptionHandlers(httpServer)

httpServer.listen(PORT, () => { ... // ìˆ˜ì •
```

- ğŸ’¦error :  `"Cannot read property 'headers' of undefined"`
  - ì›¹ì†Œì¼“ì€ request, responseê°€ ì—†ìŒ (ëŒ€ì‹  connectionì´ë€ê²Œ ìˆìŒ)

```js
context: async ({ req }) => {
        return {
            loggedInUser:
                              // ì´ë¶€ë¶„
                await getUser(req.headers.token),
        };
    }
```

- if (req) { ~} ë¡œ ìˆ˜ì •í•˜ê³  playgroundì—ì„œ ì‹¤í–‰



**How/Where to publish the event(NEW_MESSAGE)**

- after creating a message, publish the event
- `pubsub.publish(triggerName,payload)`
  - payload needs to be an object (name_of_subscription : return type of subscription)

```js
// sendMessage.resolvers
const message = await client.message.create({...})
pubsub.publish(NEW_MESSAGE, { roomUpdates: { ...message } });
// "message" objectê°€ ì•„ë‹ˆë¼ ê·¸ ì•ˆì˜ ë‚´ìš©ì´ í•„ìš”

return {...}

```

- ê°„ë‹¨ì •ë¦¬

1. **subscribe** : asyncIteratorë¥¼ ì´ë²¤íŠ¸ì˜ ì´ë¦„ê³¼ í•¨ê»˜  return (roomUpdates.resolvers)
2. **publish** : ì´ë²¤íŠ¸ì˜ ì´ë¦„ê³¼ payloadë¥¼ publish (sendMessage.resolvers)



**when should i use subscription?**

- small, incremental changes to large objects (ex. ì¢‹ì•„ìš” ê°œìˆ˜ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸)
- low-latency, real-time updates (ex. chatting)

