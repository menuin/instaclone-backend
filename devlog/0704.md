## 🥨 DEVLOG 7/4

### #3.12 Recap

- 도메인 별로 분리 (movies, users, comments, photos 등이 한 폴더에 전부 정리되어 있음)

- 다양한 파일들을 기반으로 schema를 만든다 (항상 export default 해야한다는 걸 기억!)

- 기존에 만든 movies, prisma 폴더 삭제, 데이터베이스 삭제하고 같은 이름으로 다시 만들기

   => 이제 본격적으로 클론 코딩 시작!



### #4.0 Create account part 1

- backend의 **User** 파트 먼저 시작!
- movie 할때랑 똑같은 과정으로 한다
- prisma 폴더를 다 지웠으니 다시 만든다 : npx prisma init => schema.prisma 파일 생성됨

1. **Write user model**

```js
// schema.prisma 에 하단 내용 추가

model User {
  id Int @id @default(autoincrement())
  firstName String
  lastName String? // 필수항목이 아님
  username String @unique  // unique한 값이어야 한다
  email String @unique
  password String 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```



2. **Migrate**

- npm run migrate (저번에 package.json 에 명령어 지정해놓았음)
- 💦 P1001 에러의 경우 .env의 DATABASE_URL에 비밀번호까지 적어줘야함
- prisma client 생성됨



3. **schema - typeDef 작성**

- user 폴더 생성 -> 그 안에 users.mutations.js / users.queries.js / users.typeDefs.js 생성
- prisma schema 와 graphql schema를 동기화 (⭐**prisma schema를 수정할 때는 항상 migrate해야한다**⭐)

```js
// users.typeDefs.js

import {gql} from "apollo-server";

export default gql`
    type User {
        id: String!
        firstName:String!
        lastName : String
        username : String!
        email : String!
        createdAt : String!
        updatedAt : String!
    }

    type Mutation {
        createAccount (
            firstName:String!
            lastName : String
            username : String!
            email : String!
            password : String!
        ) : User
    } // 

	type Query {
        seeProfile(username:String) : User
    }
`
```



### #4.1 Create Account part 2

- createAccount 의 resolver 만들기

  - 고려사항 : username의 경우 @unique로 지정되어있어서 같은 username을 만들려고 해도 db에서 에러가 날 것임 -> 하지만!! db까지 가서 에러가 나게 냅두면 안됨(유저가 db에러를 보게 냅두면 안됨), 그전에 코드로 방어⚔해줘야 한다

    

    #### STEP 1 : check if username or email are already on DB.

```js
// users.mutations.js

import client from "../client";

export default {
    Mutation : {
        // client가 db에서 찾아 돌아오는데 시간이 걸리기 때문에 async, await 사용
        createAccount : async (_, { firstName,lastName,username,email,password})=> {
            // STEP 1 : check if username or email are already on db
            const existingUser = await client.user.findFirst({
                where : { // 조건
                        OR : [ // 두가지 조건 중 하나 만족 (username이 같거나, email이 같거나)
                            {
                                username : username, // 그냥 username이라고써도됨
                            },
                            {
                                email,
                            },
                        ],
                },
            });
            console.log(existingUser);
        }
    }
}
```

📌 prisma는 promise를 리턴하기 때문에 async, await 사용한다

- **promise** : 코드에서 즉시 이뤄지지 않는 것 (ex. db에 가서 정보를 가져오는 것)

📌 **prisma는 await를 해줘야 다음 코드로 넘어갈 수 있다**



### #4.2 Create Account part 3

#### STEP 2 : HASHING

- 사용자가 계정을 만들때 비밀번호를 보냄 => DB에 날것의 비밀번호를 저장하면 큰일남! 

  - 우리는 비밀번호를 기억하고 싶지만, 실제 비밀번호가 뭔지 알고싶지는 않다

- **hashing** : ugly representation of text

  - 비밀번호를 보낼 때, hashing function에 담아서 보낸다 ex) 1234 -> fn(1234) -> dfkwejr
  - 변환된 텍스트가 DB에 담기게 됨

  - hashing 은 **단방향 함수!** 즉 dfkwejr -> fn(dfkwejr) -> 1234 이렇게는 할 수 없음

  - 로그인 시 비밀번호가 맞는 지 확인할 때도 hashing function을 사용해서 같은 방식으로 확인

- npm i bcrypt << hashing package의 일종

- **salt** 는 hash 끝에 무작위로 추가되는 텍스트이다

```js
// users.mutations.js 
// STEP 1 뒤로 추가

// STEP 2 : hash password
const uglyPassword = await bcrypt.hash(password, 10); // salt = 10
console.log(uglyPassword);
```

#### STEP 3 : SAVE AND RETURN THE USER

```JS
Mutation : {
        createAccount : async (_, { firstName,lastName,username,email,password}) => {
            
            // STEP 1 : check if username or email are already on db
            const existingUser = await client.user.findFirst({
                where : {
                        OR : [
                            {
                                username : username,
                            },
                            {
                                email,
                            },
                        ],
                },
            });

            // STEP 2 : hash password
            const uglyPassword = await bcrypt.hash(password, 10);

            // STEP 3 : save and return the user
            return client.user.create({ data : {
                username,
                email, 
                firstName, 
                lastName, 
                password : uglyPassword,
            }})
        }
    }
```



- playground에서 실행해보기

```js
// playground 
mutation {
  createAccount(
    firstName : "Menuin"
    lastName : "Kim"
    email : "menuin@naver.com"
    password : "123"
    username : "menuin"
  ) {
    username  // 이렇게 subfield를 선택해줘야함
  }
}
```

- npm run studio로 테이블을 열어서 hash된 비밀번호 확인해보기

#### STEP 4 : ERROR HANDLING

```js
Mutation : {
        createAccount : async (_, { firstName,lastName,username,email,password}) => {
            try{
                // STEP 1 : check if username or email are already on db
                const existingUser = await client.user.findFirst({
                    where : {
                            OR : [
                                {
                                    username : username,
                                },
                                {
                                    email,
                                },
                            ],
                    },
                });
                if (existingUser){
                    throw new Error("This username/email is already taken.");
                }

                // STEP 2 : hash password
               // STEP 3 : save and return the user
                
                }})
        } catch (e) {  // 에러비상구
            return e;
        }
        }
    }
```

📌 await 를 사용하면 try-catch문을 사용하는 것이 낫다

### #4.3 seeProfile

- typeDefs 에는 이미 작성해 놓았음!

  ```js
  // users.typeDefs.js
  
     type Query {
          seeProfile(username:String) : User
      }
  ```

📌 `findUnique()`는 @unique 속성을 가진 필드만 찾는다 (username, email, id 같은거)

```js
// users.queries.js

import client from "../client";

export default {
    Query : {
        seeProfile : (_, {username}) => client.user.findUnique({
            where  : {
                username,
            }
        })
    }
}
```



