## ğŸ¥¨ DEVLOG 7/4

### #3.12 Recap

- ë„ë©”ì¸ ë³„ë¡œ ë¶„ë¦¬ (movies, users, comments, photos ë“±ì´ í•œ í´ë”ì— ì „ë¶€ ì •ë¦¬ë˜ì–´ ìˆìŒ)

- ë‹¤ì–‘í•œ íŒŒì¼ë“¤ì„ ê¸°ë°˜ìœ¼ë¡œ schemaë¥¼ ë§Œë“ ë‹¤ (í•­ìƒ export default í•´ì•¼í•œë‹¤ëŠ” ê±¸ ê¸°ì–µ!)

- ê¸°ì¡´ì— ë§Œë“  movies, prisma í´ë” ì‚­ì œ, ë°ì´í„°ë² ì´ìŠ¤ ì‚­ì œí•˜ê³  ê°™ì€ ì´ë¦„ìœ¼ë¡œ ë‹¤ì‹œ ë§Œë“¤ê¸°

   => ì´ì œ ë³¸ê²©ì ìœ¼ë¡œ í´ë¡  ì½”ë”© ì‹œì‘!



### #4.0 Create account part 1

- backendì˜ **User** íŒŒíŠ¸ ë¨¼ì € ì‹œì‘!
- movie í• ë•Œë‘ ë˜‘ê°™ì€ ê³¼ì •ìœ¼ë¡œ í•œë‹¤
- prisma í´ë”ë¥¼ ë‹¤ ì§€ì› ìœ¼ë‹ˆ ë‹¤ì‹œ ë§Œë“ ë‹¤ : npx prisma init => schema.prisma íŒŒì¼ ìƒì„±ë¨

1. **Write user model**

```js
// schema.prisma ì— í•˜ë‹¨ ë‚´ìš© ì¶”ê°€

model User {
  id Int @id @default(autoincrement())
  firstName String
  lastName String? // í•„ìˆ˜í•­ëª©ì´ ì•„ë‹˜
  username String @unique  // uniqueí•œ ê°’ì´ì–´ì•¼ í•œë‹¤
  email String @unique
  password String 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```



2. **Migrate**

- npm run migrate (ì €ë²ˆì— package.json ì— ëª…ë ¹ì–´ ì§€ì •í•´ë†“ì•˜ìŒ)
- ğŸ’¦ P1001 ì—ëŸ¬ì˜ ê²½ìš° .envì˜ DATABASE_URLì— ë¹„ë°€ë²ˆí˜¸ê¹Œì§€ ì ì–´ì¤˜ì•¼í•¨
- prisma client ìƒì„±ë¨



3. **schema - typeDef ì‘ì„±**

- user í´ë” ìƒì„± -> ê·¸ ì•ˆì— users.mutations.js / users.queries.js / users.typeDefs.js ìƒì„±
- prisma schema ì™€ graphql schemaë¥¼ ë™ê¸°í™” (â­**prisma schemaë¥¼ ìˆ˜ì •í•  ë•ŒëŠ” í•­ìƒ migrateí•´ì•¼í•œë‹¤**â­)

```js
// users.typeDefs.js

import {gql} from "apollo-server";

export default gql`
    type User {
        id: String!
        firstName:String!
        lastName : String
        username : String!
        email : String!
        createdAt : String!
        updatedAt : String!
    }

    type Mutation {
        createAccount (
            firstName:String!
            lastName : String
            username : String!
            email : String!
            password : String!
        ) : User
    } // 

	type Query {
        seeProfile(username:String) : User
    }
`
```



### #4.1 Create Account part 2

- createAccount ì˜ resolver ë§Œë“¤ê¸°

  - ê³ ë ¤ì‚¬í•­ : usernameì˜ ê²½ìš° @uniqueë¡œ ì§€ì •ë˜ì–´ìˆì–´ì„œ ê°™ì€ usernameì„ ë§Œë“¤ë ¤ê³  í•´ë„ dbì—ì„œ ì—ëŸ¬ê°€ ë‚  ê²ƒì„ -> í•˜ì§€ë§Œ!! dbê¹Œì§€ ê°€ì„œ ì—ëŸ¬ê°€ ë‚˜ê²Œ ëƒ…ë‘ë©´ ì•ˆë¨(ìœ ì €ê°€ dbì—ëŸ¬ë¥¼ ë³´ê²Œ ëƒ…ë‘ë©´ ì•ˆë¨), ê·¸ì „ì— ì½”ë“œë¡œ ë°©ì–´âš”í•´ì¤˜ì•¼ í•œë‹¤

    

    #### STEP 1 : check if username or email are already on DB.

```js
// users.mutations.js

import client from "../client";

export default {
    Mutation : {
        // clientê°€ dbì—ì„œ ì°¾ì•„ ëŒì•„ì˜¤ëŠ”ë° ì‹œê°„ì´ ê±¸ë¦¬ê¸° ë•Œë¬¸ì— async, await ì‚¬ìš©
        createAccount : async (_, { firstName,lastName,username,email,password})=> {
            // STEP 1 : check if username or email are already on db
            const existingUser = await client.user.findFirst({
                where : { // ì¡°ê±´
                        OR : [ // ë‘ê°€ì§€ ì¡°ê±´ ì¤‘ í•˜ë‚˜ ë§Œì¡± (usernameì´ ê°™ê±°ë‚˜, emailì´ ê°™ê±°ë‚˜)
                            {
                                username : username, // ê·¸ëƒ¥ usernameì´ë¼ê³ ì¨ë„ë¨
                            },
                            {
                                email,
                            },
                        ],
                },
            });
            console.log(existingUser);
        }
    }
}
```

ğŸ“Œ prismaëŠ” promiseë¥¼ ë¦¬í„´í•˜ê¸° ë•Œë¬¸ì— async, await ì‚¬ìš©í•œë‹¤

- **promise** : ì½”ë“œì—ì„œ ì¦‰ì‹œ ì´ë¤„ì§€ì§€ ì•ŠëŠ” ê²ƒ (ex. dbì— ê°€ì„œ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ê²ƒ)

ğŸ“Œ **prismaëŠ” awaitë¥¼ í•´ì¤˜ì•¼ ë‹¤ìŒ ì½”ë“œë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìˆë‹¤**



### #4.2 Create Account part 3

#### STEP 2 : HASHING

- ì‚¬ìš©ìê°€ ê³„ì •ì„ ë§Œë“¤ë•Œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³´ëƒ„ => DBì— ë‚ ê²ƒì˜ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì €ì¥í•˜ë©´ í°ì¼ë‚¨! 

  - ìš°ë¦¬ëŠ” ë¹„ë°€ë²ˆí˜¸ë¥¼ ê¸°ì–µí•˜ê³  ì‹¶ì§€ë§Œ, ì‹¤ì œ ë¹„ë°€ë²ˆí˜¸ê°€ ë­”ì§€ ì•Œê³ ì‹¶ì§€ëŠ” ì•Šë‹¤

- **hashing** : ugly representation of text

  - ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³´ë‚¼ ë•Œ, hashing functionì— ë‹´ì•„ì„œ ë³´ë‚¸ë‹¤ ex) 1234 -> fn(1234) -> dfkwejr
  - ë³€í™˜ëœ í…ìŠ¤íŠ¸ê°€ DBì— ë‹´ê¸°ê²Œ ë¨

  - hashing ì€ **ë‹¨ë°©í–¥ í•¨ìˆ˜!** ì¦‰ dfkwejr -> fn(dfkwejr) -> 1234 ì´ë ‡ê²ŒëŠ” í•  ìˆ˜ ì—†ìŒ

  - ë¡œê·¸ì¸ ì‹œ ë¹„ë°€ë²ˆí˜¸ê°€ ë§ëŠ” ì§€ í™•ì¸í•  ë•Œë„ hashing functionì„ ì‚¬ìš©í•´ì„œ ê°™ì€ ë°©ì‹ìœ¼ë¡œ í™•ì¸

- npm i bcrypt << hashing packageì˜ ì¼ì¢…

- **salt** ëŠ” hash ëì— ë¬´ì‘ìœ„ë¡œ ì¶”ê°€ë˜ëŠ” í…ìŠ¤íŠ¸ì´ë‹¤

```js
// users.mutations.js 
// STEP 1 ë’¤ë¡œ ì¶”ê°€

// STEP 2 : hash password
const uglyPassword = await bcrypt.hash(password, 10); // salt = 10
console.log(uglyPassword);
```

#### STEP 3 : SAVE AND RETURN THE USER

```JS
Mutation : {
        createAccount : async (_, { firstName,lastName,username,email,password}) => {
            
            // STEP 1 : check if username or email are already on db
            const existingUser = await client.user.findFirst({
                where : {
                        OR : [
                            {
                                username : username,
                            },
                            {
                                email,
                            },
                        ],
                },
            });

            // STEP 2 : hash password
            const uglyPassword = await bcrypt.hash(password, 10);

            // STEP 3 : save and return the user
            return client.user.create({ data : {
                username,
                email, 
                firstName, 
                lastName, 
                password : uglyPassword,
            }})
        }
    }
```



- playgroundì—ì„œ ì‹¤í–‰í•´ë³´ê¸°

```js
// playground 
mutation {
  createAccount(
    firstName : "Menuin"
    lastName : "Kim"
    email : "menuin@naver.com"
    password : "123"
    username : "menuin"
  ) {
    username  // ì´ë ‡ê²Œ subfieldë¥¼ ì„ íƒí•´ì¤˜ì•¼í•¨
  }
}
```

- npm run studioë¡œ í…Œì´ë¸”ì„ ì—´ì–´ì„œ hashëœ ë¹„ë°€ë²ˆí˜¸ í™•ì¸í•´ë³´ê¸°

#### STEP 4 : ERROR HANDLING

```js
Mutation : {
        createAccount : async (_, { firstName,lastName,username,email,password}) => {
            try{
                // STEP 1 : check if username or email are already on db
                const existingUser = await client.user.findFirst({
                    where : {
                            OR : [
                                {
                                    username : username,
                                },
                                {
                                    email,
                                },
                            ],
                    },
                });
                if (existingUser){
                    throw new Error("This username/email is already taken.");
                }

                // STEP 2 : hash password
               // STEP 3 : save and return the user
                
                }})
        } catch (e) {  // ì—ëŸ¬ë¹„ìƒêµ¬
            return e;
        }
        }
    }
```

ğŸ“Œ await ë¥¼ ì‚¬ìš©í•˜ë©´ try-catchë¬¸ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë‚«ë‹¤

### #4.3 seeProfile

- typeDefs ì—ëŠ” ì´ë¯¸ ì‘ì„±í•´ ë†“ì•˜ìŒ!

  ```js
  // users.typeDefs.js
  
     type Query {
          seeProfile(username:String) : User
      }
  ```

ğŸ“Œ `findUnique()`ëŠ” @unique ì†ì„±ì„ ê°€ì§„ í•„ë“œë§Œ ì°¾ëŠ”ë‹¤ (username, email, id ê°™ì€ê±°)

```js
// users.queries.js

import client from "../client";

export default {
    Query : {
        seeProfile : (_, {username}) => client.user.findUnique({
            where  : {
                username,
            }
        })
    }
}
```



